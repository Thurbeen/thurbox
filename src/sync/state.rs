use std::path::PathBuf;

use serde::{Deserialize, Serialize};

use crate::project::ProjectId;
use crate::session::SessionId;

/// Default time-to-live for deleted session tombstones (60 seconds in millis).
const TOMBSTONE_TTL_MS: u64 = 60_000;

/// Current shared state format version.
const SHARED_STATE_VERSION: u32 = 1;

/// Complete shared state across all thurbox instances.
///
/// This structure is serialized to TOML and read/written by instances
/// in real-time. All fields are shared except local UI state.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SharedState {
    /// Version of the shared state format (for future migrations).
    pub version: u32,

    /// Timestamp (millis since epoch) when this state was last modified.
    /// Used for conflict detection: if two instances write simultaneously,
    /// the one with the later timestamp wins.
    pub last_modified: u64,

    /// Session counter for unique naming across instances.
    /// Incremented by whichever instance creates the next session.
    pub session_counter: usize,

    /// All sessions known across all instances.
    /// Includes both active and tombstoned (deleted) sessions.
    pub sessions: Vec<SharedSession>,

    /// All projects known across all instances.
    /// Projects created or modified by any instance are shared here.
    #[serde(default)]
    pub projects: Vec<SharedProject>,
}

impl SharedState {
    /// Create a new empty shared state.
    pub fn new() -> Self {
        Self {
            version: SHARED_STATE_VERSION,
            last_modified: current_time_millis(),
            session_counter: 0,
            sessions: Vec::new(),
            projects: Vec::new(),
        }
    }

    /// Purge deleted sessions (tombstones older than TTL).
    /// Called after reading shared state to clean up old deletions.
    pub fn purge_old_tombstones(&mut self) {
        let now = current_time_millis();
        self.sessions.retain(|session| {
            if !session.tombstone {
                return true;
            }
            let tombstone_at = session.tombstone_at.unwrap_or(now);
            now - tombstone_at < TOMBSTONE_TTL_MS
        });
    }
}

impl Default for SharedState {
    fn default() -> Self {
        Self::new()
    }
}

/// A session known to the shared state.
///
/// Tracks essential metadata needed for all instances to see and adopt sessions.
/// Can be tombstoned (marked deleted) for graceful cleanup across instances.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SharedSession {
    /// Unique session identifier (generated by spawning instance).
    pub id: SessionId,

    /// Human-readable session name (e.g., "1", "Session 1").
    pub name: String,

    /// Project this session belongs to.
    pub project_id: ProjectId,

    /// Role assigned to this session (e.g., "developer", "reviewer").
    pub role: String,

    /// Backend identifier for finding the session in tmux.
    /// Format: "thurbox:@0" for local tmux sessions.
    pub backend_id: String,

    /// Backend type (e.g., "tmux").
    pub backend_type: String,

    /// The underlying Claude session ID (if started).
    #[serde(skip_serializing_if = "Option::is_none")]
    pub claude_session_id: Option<String>,

    /// Working directory (if specified).
    #[serde(skip_serializing_if = "Option::is_none")]
    pub cwd: Option<PathBuf>,

    /// Optional worktree information (if session is for a git worktree).
    #[serde(skip_serializing_if = "Option::is_none")]
    pub worktree: Option<SharedWorktree>,

    /// Tombstone flag: true if this session was deleted by another instance.
    /// Tombstoned sessions are excluded from normal operations but kept
    /// temporarily to allow all instances to see the deletion.
    #[serde(default)]
    pub tombstone: bool,

    /// Timestamp when this session was tombstoned (millis since epoch).
    /// Used to clean up old tombstones after TTL.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub tombstone_at: Option<u64>,
}

/// A project known to the shared state.
///
/// Projects are shared across all instances to enable cross-instance
/// visibility and synchronization. When one instance creates a project,
/// other instances see it in the shared state and can adopt it.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SharedProject {
    /// Unique project identifier (derived deterministically from project name).
    pub id: ProjectId,

    /// Human-readable project name.
    pub name: String,

    /// Repository paths associated with this project.
    pub repos: Vec<PathBuf>,
}

/// Worktree information embedded in shared session.
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
pub struct SharedWorktree {
    /// Path to the git repository root.
    pub repo_path: PathBuf,

    /// Path to the git worktree.
    pub worktree_path: PathBuf,

    /// Branch name for this worktree.
    pub branch: String,
}

/// Get current time in milliseconds since Unix epoch.
pub fn current_time_millis() -> u64 {
    std::time::SystemTime::now()
        .duration_since(std::time::UNIX_EPOCH)
        .map(|d| d.as_millis() as u64)
        .unwrap_or(0)
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn new_shared_state_is_empty_and_valid() {
        let state = SharedState::new();
        assert_eq!(state.version, SHARED_STATE_VERSION);
        assert_eq!(state.session_counter, 0);
        assert!(state.sessions.is_empty());
        assert!(state.projects.is_empty());
        assert!(state.last_modified > 0);
    }

    #[test]
    fn serialize_deserialize_roundtrip() {
        let mut state = SharedState::new();
        state.session_counter = 5;
        state.sessions.push(SharedSession {
            id: SessionId::default(),
            name: "Test Session".to_string(),
            project_id: ProjectId::default(),
            role: "developer".to_string(),
            backend_id: "thurbox:@0".to_string(),
            backend_type: "tmux".to_string(),
            claude_session_id: Some("claude-123".to_string()),
            cwd: Some(PathBuf::from("/home/user")),
            worktree: Some(SharedWorktree {
                repo_path: PathBuf::from("/home/user/repos/main"),
                worktree_path: PathBuf::from("/home/user/repos/main/.git/worktrees/feature"),
                branch: "feature".to_string(),
            }),
            tombstone: false,
            tombstone_at: None,
        });

        let toml_str = toml::to_string_pretty(&state).expect("serialize failed");
        let deserialized: SharedState = toml::from_str(&toml_str).expect("deserialize failed");

        assert_eq!(deserialized.version, state.version);
        assert_eq!(deserialized.session_counter, state.session_counter);
        assert_eq!(deserialized.sessions.len(), 1);
        assert_eq!(deserialized.sessions[0].name, "Test Session");
        assert_eq!(
            deserialized.sessions[0].claude_session_id,
            Some("claude-123".to_string())
        );
    }

    #[test]
    fn purge_old_tombstones_removes_expired() {
        let mut state = SharedState::new();
        let old_time = current_time_millis() - TOMBSTONE_TTL_MS - 1000;

        state.sessions.push(SharedSession {
            id: SessionId::default(),
            name: "Old Tombstone".to_string(),
            project_id: ProjectId::default(),
            role: "developer".to_string(),
            backend_id: "thurbox:@0".to_string(),
            backend_type: "tmux".to_string(),
            claude_session_id: None,
            cwd: None,
            worktree: None,
            tombstone: true,
            tombstone_at: Some(old_time),
        });

        state.sessions.push(SharedSession {
            id: SessionId::default(),
            name: "Recent Tombstone".to_string(),
            project_id: ProjectId::default(),
            role: "developer".to_string(),
            backend_id: "thurbox:@0".to_string(),
            backend_type: "tmux".to_string(),
            claude_session_id: None,
            cwd: None,
            worktree: None,
            tombstone: true,
            tombstone_at: Some(current_time_millis()),
        });

        state.sessions.push(SharedSession {
            id: SessionId::default(),
            name: "Active Session".to_string(),
            project_id: ProjectId::default(),
            role: "developer".to_string(),
            backend_id: "thurbox:@0".to_string(),
            backend_type: "tmux".to_string(),
            claude_session_id: None,
            cwd: None,
            worktree: None,
            tombstone: false,
            tombstone_at: None,
        });

        assert_eq!(state.sessions.len(), 3);

        state.purge_old_tombstones();

        assert_eq!(state.sessions.len(), 2);
        assert!(state.sessions.iter().all(|s| {
            if s.tombstone {
                s.tombstone_at.is_some()
            } else {
                true
            }
        }));
    }

    #[test]
    fn skip_serializing_none_fields() {
        let session = SharedSession {
            id: SessionId::default(),
            name: "Minimal".to_string(),
            project_id: ProjectId::default(),
            role: "developer".to_string(),
            backend_id: "thurbox:@0".to_string(),
            backend_type: "tmux".to_string(),
            claude_session_id: None,
            cwd: None,
            worktree: None,
            tombstone: false,
            tombstone_at: None,
        };

        let toml_str = toml::to_string(&session).expect("serialize failed");
        assert!(!toml_str.contains("claude_session_id"));
        assert!(!toml_str.contains("cwd"));
        assert!(!toml_str.contains("worktree"));
        assert!(!toml_str.contains("tombstone_at"));
    }
}
