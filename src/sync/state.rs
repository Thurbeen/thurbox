use std::path::PathBuf;

use crate::project::ProjectId;
use crate::session::{RoleConfig, SessionId};

/// Current shared state format version.
const SHARED_STATE_VERSION: u32 = 1;

/// In-memory snapshot of shared state across all thurbox instances.
///
/// Used for computing deltas between local and database state.
#[derive(Debug, Clone)]
pub struct SharedState {
    /// Version of the shared state format.
    pub version: u32,

    /// Timestamp (millis since epoch) when this snapshot was taken.
    pub last_modified: u64,

    /// Session counter for unique naming across instances.
    pub session_counter: usize,

    /// Active sessions across all instances.
    pub sessions: Vec<SharedSession>,

    /// Active projects across all instances.
    pub projects: Vec<SharedProject>,
}

impl SharedState {
    /// Create a new empty shared state.
    pub fn new() -> Self {
        Self {
            version: SHARED_STATE_VERSION,
            last_modified: current_time_millis(),
            session_counter: 0,
            sessions: Vec::new(),
            projects: Vec::new(),
        }
    }
}

impl Default for SharedState {
    fn default() -> Self {
        Self::new()
    }
}

/// A session known to the shared state.
///
/// Tracks essential metadata needed for all instances to see and adopt sessions.
#[derive(Debug, Clone)]
pub struct SharedSession {
    /// Unique session identifier (generated by spawning instance).
    pub id: SessionId,

    /// Human-readable session name (e.g., "1", "Session 1").
    pub name: String,

    /// Project this session belongs to.
    pub project_id: ProjectId,

    /// Role assigned to this session (e.g., "developer", "reviewer").
    pub role: String,

    /// Backend identifier for finding the session in tmux.
    /// Format: "thurbox:@0" for local tmux sessions.
    pub backend_id: String,

    /// Backend type (e.g., "tmux").
    pub backend_type: String,

    /// The underlying Claude session ID (if started).
    pub claude_session_id: Option<String>,

    /// Working directory (if specified).
    pub cwd: Option<PathBuf>,

    /// Optional worktree information (if session is for a git worktree).
    pub worktree: Option<SharedWorktree>,

    /// Tombstone flag: true if this session was soft-deleted.
    /// Soft-deleted sessions are excluded from active listings.
    pub tombstone: bool,

    /// Timestamp when this session was tombstoned (millis since epoch).
    pub tombstone_at: Option<u64>,
}

/// A project known to the shared state.
#[derive(Debug, Clone)]
pub struct SharedProject {
    /// Unique project identifier (derived deterministically from project name).
    pub id: ProjectId,

    /// Human-readable project name.
    pub name: String,

    /// Repository paths associated with this project.
    pub repos: Vec<PathBuf>,

    /// Role definitions for this project.
    pub roles: Vec<RoleConfig>,
}

/// Worktree information embedded in shared session.
#[derive(Debug, Clone, PartialEq)]
pub struct SharedWorktree {
    /// Path to the git repository root.
    pub repo_path: PathBuf,

    /// Path to the git worktree.
    pub worktree_path: PathBuf,

    /// Branch name for this worktree.
    pub branch: String,
}

/// Get current time in milliseconds since Unix epoch.
pub fn current_time_millis() -> u64 {
    std::time::SystemTime::now()
        .duration_since(std::time::UNIX_EPOCH)
        .map(|d| d.as_millis() as u64)
        .unwrap_or(0)
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn new_shared_state_is_empty_and_valid() {
        let state = SharedState::new();
        assert_eq!(state.version, SHARED_STATE_VERSION);
        assert_eq!(state.session_counter, 0);
        assert!(state.sessions.is_empty());
        assert!(state.projects.is_empty());
        assert!(state.last_modified > 0);
    }

    #[test]
    fn default_state_equals_new() {
        let new_state = SharedState::new();
        let default_state = SharedState::default();
        assert_eq!(new_state.version, default_state.version);
        assert_eq!(new_state.session_counter, default_state.session_counter);
    }
}
